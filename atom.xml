<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://523600.github.io/jsx-s-blog.github.io/</id>
    <title>Gridea</title>
    <updated>2021-05-26T10:40:30.719Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://523600.github.io/jsx-s-blog.github.io/"/>
    <link rel="self" href="https://523600.github.io/jsx-s-blog.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://523600.github.io/jsx-s-blog.github.io/images/avatar.png</logo>
    <icon>https://523600.github.io/jsx-s-blog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[计算机网络]]></title>
        <id>https://523600.github.io/jsx-s-blog.github.io/post/ji-suan-ji-wang-luo/</id>
        <link href="https://523600.github.io/jsx-s-blog.github.io/post/ji-suan-ji-wang-luo/">
        </link>
        <updated>2021-05-26T10:37:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="传输层服务">传输层服务</h2>
<p>​	为运行在不同host之间的应用提供通信。将两个端系统的IP交付服务拓展为端系统进程上的交付服务。依赖于网络层服务，对网络层服务进行加强。</p>
<p>​	运行在传输层上的数据被称为报文段(segment)。</p>
<h3 id="多路复用">多路复用</h3>
<p>传输层将上层不同进程socket传来的数据封装成报文段传送给网络层发送。</p>
<h3 id="多路分解">多路分解</h3>
<p>接收方接受报文段，根据所带的元组（唯一标识）分解给不同的socket：UDP socket或TCP socket。</p>
<p>![](D:\ellune\blog\img\批注 2021-05-25 161122.png)</p>
<h2 id="udp">UDP</h2>
<p>基于不可靠的IP协议之上的不可靠传输。对IP协议的简单加强。</p>
<p>提供了：</p>
<p>​	不可靠、无序的数据传输</p>
<p>​	简单的差错检测。</p>
<p>与TCP相比：</p>
<p>​	不需要建立连接。因而也不需要维持连接。</p>
<p>​	没有拥塞控制，应用层可以更好地调节速率。</p>
<p>​	头部开销少。TCP  20字节，UDP  8字节。</p>
<p>报文段结构：</p>
<figure data-type="image" tabindex="1"><img src="https://523600.github.io/jsx-s-blog.github.io//post-images/1622025610225.png" alt="" loading="lazy"></figure>
<h2 id="tcp">TCP</h2>
<h2 id="滑动窗口协议">滑动窗口协议</h2>
<p>发送方和接收方维护两个窗口。</p>
<p>窗口由已发送未确认和未发送报文段构成。当丢包时，丢失分组ack没有收到，发送方会一直等待窗口base的ack，在超时时，执行重传。当收到ack时，窗口向前移动到序号最小的未确认分组处，同时顺便发送那些窗口内的未发送分组。</p>
<p>窗口大小必须小于分组数量的一半。</p>
<p>当发送窗口和接收窗口的大小固定为1时，滑动窗口协议退化为停等协议。</p>
<figure data-type="image" tabindex="2"><img src="D:%5Cellune%5Cblog%5Cimg%5C1629488-20190622120408388-1447718459.png" alt="" loading="lazy"></figure>
<img src="D:\ellune\blog\img\批注 2021-05-26 181847.png" style="zoom: 67%;" />
<h2 id="流量控制">流量控制</h2>
<p>TCP在接收方缓冲区维护一个<strong>接收窗口</strong>rwnd，在全双工服务中，每次返回数据都将rwnd放在报文段中。</p>
<p>当接收窗口为零时，接收方不再接受数据，此时发送方每次发送1比特，当rwnd有空余时继续发送信息。</p>
<img src="D:\ellune\blog\img\QQ图片20210526122336.jpg" style="zoom:50%;" />
<p>UDP不提供流量控制，在接收方缓冲区满的时候会溢出，丢失数据。</p>
<h2 id="连接的建立和关闭">连接的建立和关闭</h2>
<h4 id="三次握手-建立连接">三次握手-----建立连接</h4>
<p>发送SYN请求的一方是客户端，接收方是服务端。</p>
<p>在服务端第一次收到SYN请求时，为TCP连接分配资源。</p>
<img src="D:\ellune\blog\img\QQ图片.jpg" style="zoom: 33%;" />
<h4 id="四次挥手-关闭连接">四次挥手-----关闭连接</h4>
<p>TCP是全双工连接，客户端和服务端都要关闭一次连接。在收到FIN后，服务端依然可以发送数据。</p>
<p>故四次挥手将三次握手中的第二步拆成两步，ACK和FIN不同时发送。</p>
<img src="D:\ellune\blog\img\QQ图片20210526133327.jpg" style="zoom:33%;" />
<p>​                                                                              三次握手和四次挥手 ![三次握手和四次挥手](D:\ellune\blog\img\批注 2021-05-26 085526.png)</p>
<h2 id="拥塞控制">拥塞控制</h2>
<p>若接收缓存无限制，TCP传输速度将达到平均分配。 当接收缓存有限时，会有一部分数据因缓存溢出丢失或者发生超时而重传，传输速度中应当包含那些重传的数据。</p>
<figure data-type="image" tabindex="3"><img src="D:%5Cellune%5Cblog%5Cimg%5C20190731190238241.png" alt="" loading="lazy"></figure>
<p>带宽是有限的，发送方通过调节cwnd的值去控制传输速度。</p>
<img src="D:\ellune\blog\img\批注 2021-05-26 143420.png" style="zoom: 50%;" />
<p>当超时或发生包括首个正确的ACK在内的连续4个ACK时，发送方判断发生拥塞，此时执行拥塞控制。</p>
<p>最开始设置一个慢启动阈值。当cwnd小于阈值时，执行慢启动，当cwnd大于阈值时，执行拥塞避免。</p>
<h5 id="慢启动">慢启动</h5>
<p>当发送一个报文段并得到确认后，每有一个确认报文段将对cwnd增加一个MSS，cwnd以指数形式增长，不断试探安全传输数据的极限。</p>
<h5 id="拥塞避免">拥塞避免</h5>
<p>cwnd达到阈值之后，cwnd以线性速度增长。</p>
<h5 id="拥塞发生">拥塞发生</h5>
<p>阈值降为当前cwnd的一半。</p>
<p>当ack超时时，cwnd降为1。</p>
<p>有时数据丢失但未发生拥塞。此时执行快速恢复：当收到冗余ACK时，cwnd降为之前的一半，以线性速度恢复。</p>
<figure data-type="image" tabindex="4"><img src="D:%5Cellune%5Cblog%5Cimg%5C20190731184640178.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂记]]></title>
        <id>https://523600.github.io/jsx-s-blog.github.io/post/za-ji/</id>
        <link href="https://523600.github.io/jsx-s-blog.github.io/post/za-ji/">
        </link>
        <updated>2021-05-25T07:02:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="final">final</h1>
<h3 id="final-类">final 类</h3>
<p>此类不能被继承</p>
<h3 id="final-方法">final 方法</h3>
<p>此方法无法被子类覆写，可以重载。</p>
<p>某些情况下final方法可能会被优化成类似inline内嵌调用。（前期绑定）</p>
<p>![](D:\ellune\批注 2021-05-22 154046.png)</p>
<h3 id="final-成员">final 成员</h3>
<p><strong>final的是final修饰的引用，而不是引用所指向的对象。</strong></p>
<pre><code class="language-java">final int a=6;//final的值只能被初始化的时候赋值，初始化之后不能修改。
final Object b=new Object();
b=new Object();// 错误 不能指向新的引用
b.data=99;// 正确 final了对象引用的地址，但对象自身可以改变
</code></pre>
<p>当编译器知道final确定的值，且值为基本数据常量时，会执行以下行为：</p>
<pre><code class="language-java">String s=&quot;6666&quot;;

final String s1=&quot;666&quot;;
String s2=&quot;666&quot;;
//在编译时执行计算式
String a = s1 + 6; //编译时将final修饰的string替换到表达式中去  类似#define的行为
String b = s2 + 6;

System.out.println((a == s));//true
System.out.println((b == s));//false
</code></pre>
<h1 id="向上转型多态和向下转型">向上转型（多态）和向下转型</h1>
<p><strong>向上转型/多态：通过实现父类引用指向子类对象，可以实现传入不同的子类对象时执行不同的功能，实现参数统一。</strong></p>
<p>父类指向子类对象的引用只能实现父类和子类中都有的方法，而子类多出的方法无法使用。</p>
<p>只有在子类override了父类的方法时，才会显现出这一特性。而重载不会实现多态。</p>
<p>多态的实现基于java的动态绑定。</p>
<p>在java中只有被声明为<strong>final（private）和static</strong>的方法（在编译期绑定）才可以避免在运行时绑定（<strong>静态绑定</strong>），这也是final和static方法无法实现多态的原因（static方法可以重写，但父类调用执行的仍然是父类方法，而final无法被重写）</p>
<p><strong>重写的一个特例</strong></p>
<pre><code class="language-java">class A{
    public String data;
    A(String a){
        this.data=a;
        //System.out.println(&quot;A()&quot;);
    }
    A(){
       // System.out.println(&quot;A()&quot;);
    }

    public void print(String ... arg){
		System.out.println(&quot;A&quot;);
    }
}

final class B extends A{
    public String data;
    public B(String data) {
        super();
        this.data = data;
    }
    @Override
    public void print(String [] arg){
        System.out.println(&quot;B&quot;);
    }
}
public class Main {
    public static void main(String[] args) {
        A a = new B();//向上转型
        B b = new B();//未向上转型
        a.print(&quot;666&quot;);//执行正确
        b.print(&quot;666&quot;);//执行错误
    }

}
</code></pre>
<p>在上例中，子类对象b调用其print方法，编译器从子类中找到print方法，但是参数类型不匹配，尽管参数列表不匹配也不会跑到父类再去匹配，找到了就不再向上找了，所以无法执行；</p>
<p>而对象a做了向上转型，形参列表是由父类决定的，故可以执行。</p>
<p><strong>这是override的特例，正常情况下子类覆写必须与父类原方法参数列表一致，但此例中可以不一致而@Override注解不会报错。</strong></p>
<p><strong>向下转型：向上转型会丢失子类的一些信息。向下转型通过父类强制转换为子类,从而来调用子类独有的方法。</strong></p>
<h1 id="反射rtti">反射(RTTI)</h1>
<p>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。</p>
<pre><code class="language-java">/**
 * 获取Class对象：
 * 1.Class.forName(classname)
 * 2.Type.class
 * 3.object.getClass()
 *
 * 构造反射对象：
 * 1.Field 成员变量 get
 * 2.Constructor 构造器 getConstructor(ParamType.class...) 获取构造器
 * 3.Method 成员方法
 */
Class c= Class.forName(&quot;com.company.B&quot;);//Class.forName获取要反射的类名

Constructor con=c.getConstructor(String.class,String.class);//String.class 是String的反射
Constructor con1=c.getConstructor(String.class);
Constructor con2=c.getDeclaredConstructor();
Object b=con.newInstance(&quot;99&quot;,&quot;88&quot;);
Object b1=con1.newInstance(&quot;99&quot;);
Object b2=con2.newInstance();//newinstance实例化反射对象

Method method=c.getMethod(&quot;print&quot;,int.class,int.class);//获取对象方法
method.invoke(b,5,6);//invoke调用
method.invoke(b1,5,7);
method.invoke(b2,8,8);
</code></pre>
<table>
<thead>
<tr>
<th>常见反射api：</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>getClass()</td>
<td>获取类名</td>
</tr>
<tr>
<td>Class.forName()</td>
<td>传入类名字符串，返回Class对象</td>
</tr>
<tr>
<td>getField()  /  getFields()</td>
<td>获取public成员变量</td>
</tr>
<tr>
<td>getDeclaredField() / getDeclaredFields()</td>
<td>获取所有成员变量</td>
</tr>
<tr>
<td>getConstructor() / getConstructors()</td>
<td>获取public构造器</td>
</tr>
<tr>
<td>getDeclaredConstructor() /  getDeclaredConstructors()</td>
<td>获取所有构造器</td>
</tr>
<tr>
<td>newInstance()</td>
<td>实例化一个反射对象</td>
</tr>
<tr>
<td>getMethod()  /  getMethods()</td>
<td>获取public方法</td>
</tr>
<tr>
<td>MgetDeclaredMethod(ClassObject)  /  getDeclaredMethods(ClassObject)</td>
<td>获取所有方法</td>
</tr>
<tr>
<td>Object invoke(Object obj, Object... args)</td>
<td>执行一个方法,arg为参数</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取字段名</td>
</tr>
<tr>
<td>public Class<E>[] getParameterTypes()</td>
<td>参数列表</td>
</tr>
</tbody>
</table>
<p>(https://zhuanlan.zhihu.com/p/80519709)</p>
<h1 id="接口与抽象">接口与抽象</h1>
<h3 id="抽象">抽象</h3>
<h4 id="抽象类">抽象类</h4>
<p>抽象类和普通的类唯一区别在于抽象类无法被实例化，无法用来描绘对象，其他方面与普通类行为相同。 必须被继承才能被使用。</p>
<p>若子类也是抽象类，则需一直被继承直到子类不是抽象类才能被实例化。</p>
<h4 id="抽象方法">抽象方法</h4>
<p>声明时只给出方法，不提供具体实现，在子类中进行实现。</p>
<p><strong>当一个类中含有抽象方法时，该类必须是抽象类，但抽象类可以不含抽象方法。</strong></p>
<pre><code class="language-java">abstract class A{
    public String data;
    A(String a){
        this.data=a;
    }
    A(){
    }
    abstract public void print();//抽象方法
}

abstract class B extends A{
    public String data;
    public B(String data) {
        super();
        System.out.println( data);
        this.data = data;
    }//子类没有实现父类中的抽象方法，所以该类必须为抽象类。
}
</code></pre>
<h3 id="接口">接口</h3>
<p><strong>极度抽象的类，是抽象方法的集合</strong>。</p>
<p>所有方法都没有方法体（隐式包含public abstract）。</p>
<p>所有成员变量隐式指定为 <strong>public static final</strong> 。</p>
<p><strong>Java8</strong>中提供了新的方式：</p>
<pre><code class="language-java"> class B implements C{
    ...
}//B中没有提供接口C中static和default方法的实现

interface C {
    static void print1() {
        System.out.println(&quot;static C&quot;);
    }//只能通过接口名调用
    default void print(){
        System.out.println(&quot;default print&quot;);
    }//提供一个默认实现，子类实现类可以重写掉此实现。
}

public class Main {
    public static void main(String[] args) {
        B b=new B(&quot;B.data&quot;);
        C.print1();//输出static C
        b.print();//输出default print
    }
}
</code></pre>
<p>默认方法提供了接口演化（interface evolution），可以在旧接口中添加一个<strong>默认方法</strong>，而不至于让其他实现类报错。</p>
<p>在Java9中，接口函数可以声明为private。</p>
<h1 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h1>
<p>java中实现对象的拷贝有两种方法------<strong>赋值运算符</strong>和<strong>实现Cloneable接口</strong>。</p>
<p>赋值运算符实现的是浅拷贝。</p>
<p>Cloneable接口是一个标记接口，其内部不含任何方法。</p>
<p>若只实现了一层的clone方法，实现的依然是浅拷贝。</p>
<pre><code class="language-java">class Wheel {
    public int size;
    public Wheel(int size) {
        this.size = size;
    }
}

class Car implements Cloneable {
    public Wheel wheel;//含有一个Wheel对象
    public Car(Wheel wheel) {
        this.wheel = wheel;
    }
    @Override
    public Object clone() throws CloneNotSupportedException {
        // 覆写此方法必须调用super.clone()
        return super.clone();
    }
}

public class Main {
    public static void main(String[] args) {
        Wheel wheel=new Wheel(88);
        Car car=new Car(wheel);
        Car car1=(Car)car.clone(); //仅在car中实现clone，实现了对象的深拷贝，但car对象的wheel成员没有被拷贝，还是和之前共享地址。
        System.out.println(car1.wheel.size);//88
        car1.wheel.size=99;
        System.out.println(car.wheel.size);//99
    }
}
</code></pre>
<p>只有将类中含有的所有类都实现clone方法，才能进行彻底的深拷贝。</p>
<p>每一层的每个对象都进行浅拷贝——————深拷贝。</p>
<pre><code class="language-java">class Wheel implements Cloneable{
    public int size;
    public Wheel(int size) {
        this.size = size;
    }
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }//每个类中都实现了clone方法
}

class Car implements Cloneable {
    public Wheel wheel;
    public Car(Wheel wheel) {
        this.wheel = wheel;
    }
    @Override
    public Object clone() throws CloneNotSupportedException {
        Car car= (Car) super.clone();
        car.wheel=(Wheel)wheel.clone();
        return car;
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Wheel wheel=new Wheel(88);
        Car car=new Car(wheel);
        Car car1= (Car) car.clone();//实现了彻底的深拷贝
        System.out.println(car1.wheel.size);//88
        car1.wheel.size=99;
        System.out.println(car.wheel.size);//88
    }
}
</code></pre>
<p><strong>实现对象序列化也可实现对象的深拷贝。</strong></p>
<h1 id="参数传递">参数传递</h1>
<p>Java中没有真正的引用传递 只有值传递。</p>
<p>本质上是对象的浅拷贝。</p>
<pre><code class="language-java">private static void test1( A a){//传入实参地址的copy    A b=new A(&quot;B&quot;);    a=b;// 改变了传入参数的地址，a指向b，所以对原地址存有的对象没有进行修改，无法改变值。    ...//后续操作对main中的a无效}private static void test2( A a){//传入实参地址的copy     A b=new A(&quot;B&quot;);    a.data=b.data;// a的地址没有被修改,直接在此地址上进行修改，改变了main中a的值}public static void main(String[] args) {    A a = new A();    a.data = &quot;main A.data&quot;;    test1(a);}
</code></pre>
<h1 id="泛型">泛型</h1>
<h4 id="泛型类">泛型类</h4>
<pre><code class="language-java">class T &lt;E&gt; {    static private int index=0;    private E[] data;        public E get(int i){        return data[i];    }    public void add(E i){        data[index++]=i;    }    public T() {        this.data = (E[]) new Object[10000];    }}
</code></pre>
<h4 id="泛型方法">泛型方法</h4>
<pre><code class="language-java">public static &lt;T extends Comparable &amp; Cloneable &gt; T func(T ... a){  //用extends限定T的类型    return a[a.length/2];}
</code></pre>
<h4 id="类型擦除">类型擦除</h4>
<p>虚拟机中没有泛型，只有普通的类和方法。java虚拟机在编译期会将类型参数替换为相应的类型。这点与c++的template不同。</p>
<p>T<A> 和T<B> 在java编译后都转化为T ，c++对于每个实例化产生不同的类型。</p>
<p><strong>不能创建一个确切的泛型类型的数组，因为擦除会使该数组中每一个元素都是相同的泛型类型，而失去了菱形运算符中原有的类型，运行时虚拟机中没有泛型信息，在进行数据转换时将导致一个类型错误。</strong></p>
]]></content>
    </entry>
</feed>