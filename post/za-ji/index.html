<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gridea</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/mdui/0.4.3/css/mdui.min.css">
    <link rel="stylesheet" href="media/css/post.css">
    <link rel="stylesheet" href="media/live2d/css/live2d.css" />
    
</head>
<body class=" mdui-appbar-with-toolbar  mdui-theme-primary-pink mdui-theme-accent-pink">
<header class="mdui-toolbar mdui-color-pink mdui-appbar-fixed mdui-appbar-scroll-toolbar-hide" style="z-index: 1000">
    <a href="javascript:;" mdui-drawer="{target: '#left-drawer',overlay:true}" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
    <span class="mdui-typo-title">Gridea</span>
    <div class="mdui-toolbar-spacer"></div>
<!--    <a href="javascript:history.go(0);" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
    <a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">more_vert</i></a>
</header>

<div class="mdui-drawer mdui-color-white mdui-drawer-full-height mdui-drawer-close" id="left-drawer">
    <ul class="mdui-list">
        <li class="mdui-subheader">菜单</li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/" class="mdui-list-item-content">首页</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/archives" class="mdui-list-item-content">归档</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/tags" class="mdui-list-item-content">标签</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/post/about" class="mdui-list-item-content">关于</a>
        </li>
        
    </ul>
</div>

<div id="content" class="site-content">
    <div id="primary" class="content-area">
        <main id="main" class="site-main" role="main">
            <article id="post-1270" class="post-1270 post type-post status-publish format-standard hentry category-90 category-129 tag-149">
                <header class="entry-header">
                    <h1 class="entry-title">杂记</h1>
                    <p class="entry-census">发布于 2021-05-25</p>
                    <hr>
                </header>
                <div class="neko">
                    <h1 id="final">final</h1>
<h3 id="final-类">final 类</h3>
<p>此类不能被继承</p>
<h3 id="final-方法">final 方法</h3>
<p>此方法无法被子类覆写，可以重载。</p>
<p>某些情况下final方法可能会被优化成类似inline内嵌调用。（前期绑定）</p>
<p>![](D:\ellune\批注 2021-05-22 154046.png)</p>
<h3 id="final-成员">final 成员</h3>
<p><strong>final的是final修饰的引用，而不是引用所指向的对象。</strong></p>
<pre><code class="language-java">final int a=6;//final的值只能被初始化的时候赋值，初始化之后不能修改。
final Object b=new Object();
b=new Object();// 错误 不能指向新的引用
b.data=99;// 正确 final了对象引用的地址，但对象自身可以改变
</code></pre>
<p>当编译器知道final确定的值，且值为基本数据常量时，会执行以下行为：</p>
<pre><code class="language-java">String s=&quot;6666&quot;;

final String s1=&quot;666&quot;;
String s2=&quot;666&quot;;
//在编译时执行计算式
String a = s1 + 6; //编译时将final修饰的string替换到表达式中去  类似#define的行为
String b = s2 + 6;

System.out.println((a == s));//true
System.out.println((b == s));//false
</code></pre>
<h1 id="向上转型多态和向下转型">向上转型（多态）和向下转型</h1>
<p><strong>向上转型/多态：通过实现父类引用指向子类对象，可以实现传入不同的子类对象时执行不同的功能，实现参数统一。</strong></p>
<p>父类指向子类对象的引用只能实现父类和子类中都有的方法，而子类多出的方法无法使用。</p>
<p>只有在子类override了父类的方法时，才会显现出这一特性。而重载不会实现多态。</p>
<p>多态的实现基于java的动态绑定。</p>
<p>在java中只有被声明为<strong>final（private）和static</strong>的方法（在编译期绑定）才可以避免在运行时绑定（<strong>静态绑定</strong>），这也是final和static方法无法实现多态的原因（static方法可以重写，但父类调用执行的仍然是父类方法，而final无法被重写）</p>
<p><strong>重写的一个特例</strong></p>
<pre><code class="language-java">class A{
    public String data;
    A(String a){
        this.data=a;
        //System.out.println(&quot;A()&quot;);
    }
    A(){
       // System.out.println(&quot;A()&quot;);
    }

    public void print(String ... arg){
		System.out.println(&quot;A&quot;);
    }
}

final class B extends A{
    public String data;
    public B(String data) {
        super();
        this.data = data;
    }
    @Override
    public void print(String [] arg){
        System.out.println(&quot;B&quot;);
    }
}
public class Main {
    public static void main(String[] args) {
        A a = new B();//向上转型
        B b = new B();//未向上转型
        a.print(&quot;666&quot;);//执行正确
        b.print(&quot;666&quot;);//执行错误
    }

}
</code></pre>
<p>在上例中，子类对象b调用其print方法，编译器从子类中找到print方法，但是参数类型不匹配，尽管参数列表不匹配也不会跑到父类再去匹配，找到了就不再向上找了，所以无法执行；</p>
<p>而对象a做了向上转型，形参列表是由父类决定的，故可以执行。</p>
<p><strong>这是override的特例，正常情况下子类覆写必须与父类原方法参数列表一致，但此例中可以不一致而@Override注解不会报错。</strong></p>
<p><strong>向下转型：向上转型会丢失子类的一些信息。向下转型通过父类强制转换为子类,从而来调用子类独有的方法。</strong></p>
<h1 id="反射rtti">反射(RTTI)</h1>
<p>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。</p>
<pre><code class="language-java">/**
 * 获取Class对象：
 * 1.Class.forName(classname)
 * 2.Type.class
 * 3.object.getClass()
 *
 * 构造反射对象：
 * 1.Field 成员变量 get
 * 2.Constructor 构造器 getConstructor(ParamType.class...) 获取构造器
 * 3.Method 成员方法
 */
Class c= Class.forName(&quot;com.company.B&quot;);//Class.forName获取要反射的类名

Constructor con=c.getConstructor(String.class,String.class);//String.class 是String的反射
Constructor con1=c.getConstructor(String.class);
Constructor con2=c.getDeclaredConstructor();
Object b=con.newInstance(&quot;99&quot;,&quot;88&quot;);
Object b1=con1.newInstance(&quot;99&quot;);
Object b2=con2.newInstance();//newinstance实例化反射对象

Method method=c.getMethod(&quot;print&quot;,int.class,int.class);//获取对象方法
method.invoke(b,5,6);//invoke调用
method.invoke(b1,5,7);
method.invoke(b2,8,8);
</code></pre>
<table>
<thead>
<tr>
<th>常见反射api：</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>getClass()</td>
<td>获取类名</td>
</tr>
<tr>
<td>Class.forName()</td>
<td>传入类名字符串，返回Class对象</td>
</tr>
<tr>
<td>getField()  /  getFields()</td>
<td>获取public成员变量</td>
</tr>
<tr>
<td>getDeclaredField() / getDeclaredFields()</td>
<td>获取所有成员变量</td>
</tr>
<tr>
<td>getConstructor() / getConstructors()</td>
<td>获取public构造器</td>
</tr>
<tr>
<td>getDeclaredConstructor() /  getDeclaredConstructors()</td>
<td>获取所有构造器</td>
</tr>
<tr>
<td>newInstance()</td>
<td>实例化一个反射对象</td>
</tr>
<tr>
<td>getMethod()  /  getMethods()</td>
<td>获取public方法</td>
</tr>
<tr>
<td>MgetDeclaredMethod(ClassObject)  /  getDeclaredMethods(ClassObject)</td>
<td>获取所有方法</td>
</tr>
<tr>
<td>Object invoke(Object obj, Object... args)</td>
<td>执行一个方法,arg为参数</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取字段名</td>
</tr>
<tr>
<td>public Class<E>[] getParameterTypes()</td>
<td>参数列表</td>
</tr>
</tbody>
</table>
<p>(https://zhuanlan.zhihu.com/p/80519709)</p>
<h1 id="接口与抽象">接口与抽象</h1>
<h3 id="抽象">抽象</h3>
<h4 id="抽象类">抽象类</h4>
<p>抽象类和普通的类唯一区别在于抽象类无法被实例化，无法用来描绘对象，其他方面与普通类行为相同。 必须被继承才能被使用。</p>
<p>若子类也是抽象类，则需一直被继承直到子类不是抽象类才能被实例化。</p>
<h4 id="抽象方法">抽象方法</h4>
<p>声明时只给出方法，不提供具体实现，在子类中进行实现。</p>
<p><strong>当一个类中含有抽象方法时，该类必须是抽象类，但抽象类可以不含抽象方法。</strong></p>
<pre><code class="language-java">abstract class A{
    public String data;
    A(String a){
        this.data=a;
    }
    A(){
    }
    abstract public void print();//抽象方法
}

abstract class B extends A{
    public String data;
    public B(String data) {
        super();
        System.out.println( data);
        this.data = data;
    }//子类没有实现父类中的抽象方法，所以该类必须为抽象类。
}
</code></pre>
<h3 id="接口">接口</h3>
<p><strong>极度抽象的类，是抽象方法的集合</strong>。</p>
<p>所有方法都没有方法体（隐式包含public abstract）。</p>
<p>所有成员变量隐式指定为 <strong>public static final</strong> 。</p>
<p><strong>Java8</strong>中提供了新的方式：</p>
<pre><code class="language-java"> class B implements C{
    ...
}//B中没有提供接口C中static和default方法的实现

interface C {
    static void print1() {
        System.out.println(&quot;static C&quot;);
    }//只能通过接口名调用
    default void print(){
        System.out.println(&quot;default print&quot;);
    }//提供一个默认实现，子类实现类可以重写掉此实现。
}

public class Main {
    public static void main(String[] args) {
        B b=new B(&quot;B.data&quot;);
        C.print1();//输出static C
        b.print();//输出default print
    }
}
</code></pre>
<p>默认方法提供了接口演化（interface evolution），可以在旧接口中添加一个<strong>默认方法</strong>，而不至于让其他实现类报错。</p>
<p>在Java9中，接口函数可以声明为private。</p>
<h1 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h1>
<p>java中实现对象的拷贝有两种方法------<strong>赋值运算符</strong>和<strong>实现Cloneable接口</strong>。</p>
<p>赋值运算符实现的是浅拷贝。</p>
<p>Cloneable接口是一个标记接口，其内部不含任何方法。</p>
<p>若只实现了一层的clone方法，实现的依然是浅拷贝。</p>
<pre><code class="language-java">class Wheel {
    public int size;
    public Wheel(int size) {
        this.size = size;
    }
}

class Car implements Cloneable {
    public Wheel wheel;//含有一个Wheel对象
    public Car(Wheel wheel) {
        this.wheel = wheel;
    }
    @Override
    public Object clone() throws CloneNotSupportedException {
        // 覆写此方法必须调用super.clone()
        return super.clone();
    }
}

public class Main {
    public static void main(String[] args) {
        Wheel wheel=new Wheel(88);
        Car car=new Car(wheel);
        Car car1=(Car)car.clone(); //仅在car中实现clone，实现了对象的深拷贝，但car对象的wheel成员没有被拷贝，还是和之前共享地址。
        System.out.println(car1.wheel.size);//88
        car1.wheel.size=99;
        System.out.println(car.wheel.size);//99
    }
}
</code></pre>
<p>只有将类中含有的所有类都实现clone方法，才能进行彻底的深拷贝。</p>
<p>每一层的每个对象都进行浅拷贝——————深拷贝。</p>
<pre><code class="language-java">class Wheel implements Cloneable{
    public int size;
    public Wheel(int size) {
        this.size = size;
    }
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }//每个类中都实现了clone方法
}

class Car implements Cloneable {
    public Wheel wheel;
    public Car(Wheel wheel) {
        this.wheel = wheel;
    }
    @Override
    public Object clone() throws CloneNotSupportedException {
        Car car= (Car) super.clone();
        car.wheel=(Wheel)wheel.clone();
        return car;
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Wheel wheel=new Wheel(88);
        Car car=new Car(wheel);
        Car car1= (Car) car.clone();//实现了彻底的深拷贝
        System.out.println(car1.wheel.size);//88
        car1.wheel.size=99;
        System.out.println(car.wheel.size);//88
    }
}
</code></pre>
<p><strong>实现对象序列化也可实现对象的深拷贝。</strong></p>
<h1 id="参数传递">参数传递</h1>
<p>Java中没有真正的引用传递 只有值传递。</p>
<p>本质上是对象的浅拷贝。</p>
<pre><code class="language-java">private static void test1( A a){//传入实参地址的copy    A b=new A(&quot;B&quot;);    a=b;// 改变了传入参数的地址，a指向b，所以对原地址存有的对象没有进行修改，无法改变值。    ...//后续操作对main中的a无效}private static void test2( A a){//传入实参地址的copy     A b=new A(&quot;B&quot;);    a.data=b.data;// a的地址没有被修改,直接在此地址上进行修改，改变了main中a的值}public static void main(String[] args) {    A a = new A();    a.data = &quot;main A.data&quot;;    test1(a);}
</code></pre>
<h1 id="泛型">泛型</h1>
<h4 id="泛型类">泛型类</h4>
<pre><code class="language-java">class T &lt;E&gt; {    static private int index=0;    private E[] data;        public E get(int i){        return data[i];    }    public void add(E i){        data[index++]=i;    }    public T() {        this.data = (E[]) new Object[10000];    }}
</code></pre>
<h4 id="泛型方法">泛型方法</h4>
<pre><code class="language-java">public static &lt;T extends Comparable &amp; Cloneable &gt; T func(T ... a){  //用extends限定T的类型    return a[a.length/2];}
</code></pre>
<h4 id="类型擦除">类型擦除</h4>
<p>虚拟机中没有泛型，只有普通的类和方法。java虚拟机在编译期会将类型参数替换为相应的类型。这点与c++的template不同。</p>
<p>T<A> 和T<B> 在java编译后都转化为T ，c++对于每个实例化产生不同的类型。</p>
<p><strong>不能创建一个确切的泛型类型的数组，因为擦除会使该数组中每一个元素都是相同的泛型类型，而失去了菱形运算符中原有的类型，运行时虚拟机中没有泛型信息，在进行数据转换时将导致一个类型错误。</strong></p>

                </div>
            </article>
        </main>
    </div>
    <div class="doc-footer-nav mdui-color-theme">
        <div class="mdui-container">
            <div class="mdui-row">
                
                <a href="https://523600.github.io/jsx-s-blog.github.io/post/ji-suan-ji-wang-luo/" class="mdui-ripple mdui-color-theme mdui-col-xs-2 mdui-col-sm-6 doc-footer-nav-left">
                    <div class="doc-footer-nav-text">
                        <i class="mdui-icon material-icons">arrow_back</i>
                        <span class="doc-footer-nav-direction mdui-hidden-xs-down">上一篇文章</span>
                        <div class="doc-footer-nav-chapter mdui-hidden-xs-down">计算机网络</div>
                    </div>
                </a>
                
                
                <div class="mdui-col-xs-2 mdui-col-sm-6 doc-footer-nav-left"></div>
                
            </div>
        </div>
    </div>
    <br>
    
    <div class="comment"></div>
</div>
<footer class="mdui-container footer ">
    <div class="head_card-offset"></div>
    <div class="mdui-row mdui-row-gapless">
        <div class="k-container">
            <img width="100%" src="/media/img/skirt.png">
        </div>
    </div>

    <div class="site-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
</footer>
<div id="landlord" style="left:5px;bottom:0px;">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
            <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
            <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
            <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        <div class="live_ico_item type_music" id="musicButton"></div>
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input id="duType" value="douqilai,l2d_caihong" type="hidden">
    </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script>
    var message_Path = '/media/live2d/';//资源目录，如果目录不对请更改
    var talkAPI = "";//如果有类似图灵机器人的聊天接口请填写接口路径
</script>
<!--<script src="/media/js/jquery-3.3.1.min.js"></script>-->
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/media/live2d/js/message.js"></script>

</body>
<script src="//cdnjs.loli.net/ajax/libs/mdui/0.4.3/js/mdui.min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    $('.comment').bind('DOMNodeInserted',()=>{
        $('.comment').unbind()

        $('.vbtn').addClass(' mdui-btn mdui-color-theme-accent mdui-ripple')
    })

    let valine = new Valine({
        el: '.comment',
        
        
        
        path: window.location.pathname,
        pageSize: 30,
        avatar:'mm',
        notify:true
    })
</script>
</html>
