{"posts":[{"title":"计算机网络","content":"传输层服务 ​ 为运行在不同host之间的应用提供通信。将两个端系统的IP交付服务拓展为端系统进程上的交付服务。依赖于网络层服务，对网络层服务进行加强。 ​ 运行在传输层上的数据被称为报文段(segment)。 多路复用 传输层将上层不同进程socket传来的数据封装成报文段传送给网络层发送。 多路分解 接收方接受报文段，根据所带的元组（唯一标识）分解给不同的socket：UDP socket或TCP socket。 ![](D:\\ellune\\blog\\img\\批注 2021-05-25 161122.png) UDP 基于不可靠的IP协议之上的不可靠传输。对IP协议的简单加强。 提供了： ​ 不可靠、无序的数据传输 ​ 简单的差错检测。 与TCP相比： ​ 不需要建立连接。因而也不需要维持连接。 ​ 没有拥塞控制，应用层可以更好地调节速率。 ​ 头部开销少。TCP 20字节，UDP 8字节。 报文段结构： TCP 滑动窗口协议 发送方和接收方维护两个窗口。 窗口由已发送未确认和未发送报文段构成。当丢包时，丢失分组ack没有收到，发送方会一直等待窗口base的ack，在超时时，执行重传。当收到ack时，窗口向前移动到序号最小的未确认分组处，同时顺便发送那些窗口内的未发送分组。 窗口大小必须小于分组数量的一半。 当发送窗口和接收窗口的大小固定为1时，滑动窗口协议退化为停等协议。 流量控制 TCP在接收方缓冲区维护一个接收窗口rwnd，在全双工服务中，每次返回数据都将rwnd放在报文段中。 当接收窗口为零时，接收方不再接受数据，此时发送方每次发送1比特，当rwnd有空余时继续发送信息。 UDP不提供流量控制，在接收方缓冲区满的时候会溢出，丢失数据。 连接的建立和关闭 三次握手-----建立连接 发送SYN请求的一方是客户端，接收方是服务端。 在服务端第一次收到SYN请求时，为TCP连接分配资源。 四次挥手-----关闭连接 TCP是全双工连接，客户端和服务端都要关闭一次连接。在收到FIN后，服务端依然可以发送数据。 故四次挥手将三次握手中的第二步拆成两步，ACK和FIN不同时发送。 ​ 三次握手和四次挥手 ![三次握手和四次挥手](D:\\ellune\\blog\\img\\批注 2021-05-26 085526.png) 拥塞控制 若接收缓存无限制，TCP传输速度将达到平均分配。 当接收缓存有限时，会有一部分数据因缓存溢出丢失或者发生超时而重传，传输速度中应当包含那些重传的数据。 带宽是有限的，发送方通过调节cwnd的值去控制传输速度。 当超时或发生包括首个正确的ACK在内的连续4个ACK时，发送方判断发生拥塞，此时执行拥塞控制。 最开始设置一个慢启动阈值。当cwnd小于阈值时，执行慢启动，当cwnd大于阈值时，执行拥塞避免。 慢启动 当发送一个报文段并得到确认后，每有一个确认报文段将对cwnd增加一个MSS，cwnd以指数形式增长，不断试探安全传输数据的极限。 拥塞避免 cwnd达到阈值之后，cwnd以线性速度增长。 拥塞发生 阈值降为当前cwnd的一半。 当ack超时时，cwnd降为1。 有时数据丢失但未发生拥塞。此时执行快速恢复：当收到冗余ACK时，cwnd降为之前的一半，以线性速度恢复。 ","link":"https://523600.github.io/jsx-s-blog.github.io/post/ji-suan-ji-wang-luo/"},{"title":"杂记","content":"final final 类 此类不能被继承 final 方法 此方法无法被子类覆写，可以重载。 某些情况下final方法可能会被优化成类似inline内嵌调用。（前期绑定） ![](D:\\ellune\\批注 2021-05-22 154046.png) final 成员 final的是final修饰的引用，而不是引用所指向的对象。 当编译器知道final确定的值，且值为基本数据常量时，会执行以下行为： 向上转型（多态）和向下转型 向上转型/多态：通过实现父类引用指向子类对象，可以实现传入不同的子类对象时执行不同的功能，实现参数统一。 父类指向子类对象的引用只能实现父类和子类中都有的方法，而子类多出的方法无法使用。 只有在子类override了父类的方法时，才会显现出这一特性。而重载不会实现多态。 多态的实现基于java的动态绑定。 在java中只有被声明为final（private）和static的方法（在编译期绑定）才可以避免在运行时绑定（静态绑定），这也是final和static方法无法实现多态的原因（static方法可以重写，但父类调用执行的仍然是父类方法，而final无法被重写） 重写的一个特例 在上例中，子类对象b调用其print方法，编译器从子类中找到print方法，但是参数类型不匹配，尽管参数列表不匹配也不会跑到父类再去匹配，找到了就不再向上找了，所以无法执行； 而对象a做了向上转型，形参列表是由父类决定的，故可以执行。 这是override的特例，正常情况下子类覆写必须与父类原方法参数列表一致，但此例中可以不一致而@Override注解不会报错。 向下转型：向上转型会丢失子类的一些信息。向下转型通过父类强制转换为子类,从而来调用子类独有的方法。 反射(RTTI) Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。 常见反射api： getClass() 获取类名 Class.forName() 传入类名字符串，返回Class对象 getField() / getFields() 获取public成员变量 getDeclaredField() / getDeclaredFields() 获取所有成员变量 getConstructor() / getConstructors() 获取public构造器 getDeclaredConstructor() / getDeclaredConstructors() 获取所有构造器 newInstance() 实例化一个反射对象 getMethod() / getMethods() 获取public方法 MgetDeclaredMethod(ClassObject) / getDeclaredMethods(ClassObject) 获取所有方法 Object invoke(Object obj, Object... args) 执行一个方法,arg为参数 String getName() 获取字段名 public Class[] getParameterTypes() 参数列表 (https://zhuanlan.zhihu.com/p/80519709) 接口与抽象 抽象 抽象类 抽象类和普通的类唯一区别在于抽象类无法被实例化，无法用来描绘对象，其他方面与普通类行为相同。 必须被继承才能被使用。 若子类也是抽象类，则需一直被继承直到子类不是抽象类才能被实例化。 抽象方法 声明时只给出方法，不提供具体实现，在子类中进行实现。 当一个类中含有抽象方法时，该类必须是抽象类，但抽象类可以不含抽象方法。 接口 极度抽象的类，是抽象方法的集合。 所有方法都没有方法体（隐式包含public abstract）。 所有成员变量隐式指定为 public static final 。 Java8中提供了新的方式： 默认方法提供了接口演化（interface evolution），可以在旧接口中添加一个默认方法，而不至于让其他实现类报错。 在Java9中，接口函数可以声明为private。 浅拷贝和深拷贝 java中实现对象的拷贝有两种方法------赋值运算符和实现Cloneable接口。 赋值运算符实现的是浅拷贝。 Cloneable接口是一个标记接口，其内部不含任何方法。 若只实现了一层的clone方法，实现的依然是浅拷贝。 只有将类中含有的所有类都实现clone方法，才能进行彻底的深拷贝。 每一层的每个对象都进行浅拷贝——————深拷贝。 实现对象序列化也可实现对象的深拷贝。 参数传递 Java中没有真正的引用传递 只有值传递。 本质上是对象的浅拷贝。 泛型 泛型类 泛型方法 类型擦除 虚拟机中没有泛型，只有普通的类和方法。java虚拟机在编译期会将类型参数替换为相应的类型。这点与c++的template不同。 T 和T 在java编译后都转化为T ，c++对于每个实例化产生不同的类型。 不能创建一个确切的泛型类型的数组，因为擦除会使该数组中每一个元素都是相同的泛型类型，而失去了菱形运算符中原有的类型，运行时虚拟机中没有泛型信息，在进行数据转换时将导致一个类型错误。 ","link":"https://523600.github.io/jsx-s-blog.github.io/post/za-ji/"}]}